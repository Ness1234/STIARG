
==================== FINAL INTERFACE ====================
2017-01-13 09:07:16.7698019 UTC

interface HSMateLight-0.1.0.0-Df1CB9554xjHvhQtZIZ9Dm:Network.MateLight 8001
  interface hash: 213c42b840d146b6bd184eb44f228a9e
  ABI hash: 9a366672dd83766dca66a67b37f0eab9
  export-list hash: c8b94c94fd318946c464ca72949626ac
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d038acad6e6cc7fb65d002cd8dfe728b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Network.MateLight.parseAddress
  Network.MateLight.runMateM
  Network.MateLight.Config{Network.MateLight.Config cAddr cDimension cEventProviders cPort cStepTime cSynchronized}
  Network.MateLight.EventProviderT
  Network.MateLight.EventT{Network.MateLight.EventT}
  Network.MateLight.Frame{Network.MateLight.dimension Network.MateLight.theData}
  Network.MateLight.MateMonad
module dependencies: Network.MateLight.Debug
package dependencies: appar-0.1.4@appar-0.1.4-1in4Ewd8JBkAYDZSWXLSe0
                      array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      byteorder-1.0.4@byteorder-1.0.4-BbL4c17EpZrL9PcZm0xys9
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
                      iproute-1.7.1@iproute-1.7.1-EsJa15Wmnfj5pBTvNuT9V3
                      mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX
                      stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX:Network.Socket
         stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF:Control.Monad.STM
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         iproute-1.7.1@iproute-1.7.1-EsJa15Wmnfj5pBTvNuT9V3:Data.IP.Addr
                         iproute-1.7.1@iproute-1.7.1-EsJa15Wmnfj5pBTvNuT9V3:Data.IP.Range
import  -/  Network.MateLight.Debug a101c4bf71427567fde4cf51ed251493
  exports: ebbb461999c47e6a1adc8cec91ec135b
  debug 02eb74f61971daee1f7bb47c571b0e45
import  -/  base-4.9.0.0:Control.Concurrent c3bd1c151fa27857a3c9d1db4bfc9ff7
import  -/  base-4.9.0.0:Control.Concurrent.Chan 421cbfcb11941eb8aeba94620ec85f38
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Control.Monad.IO.Class 6093ce5ace985d5ea81901bb51e28805
import  -/  base-4.9.0.0:Data.Either 4cef602ce360a0155ac0dd580a5b4863
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:Data.Typeable 589d8ab7d073c81d7ef5f949fd3eb448
import  -/  base-4.9.0.0:Data.Typeable.Internal af418ce9ba51b5262399b6fc69c77235
import  -/  base-4.9.0.0:Data.Word cf9c7419e077bbdd2be059981bfe778f
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Conc.IO a4f5c846d1817845898e46b8578448aa
import  -/  base-4.9.0.0:GHC.Conc.Sync a1292c872414656fef080815d5d8e73c
import  -/  base-4.9.0.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.0.0:GHC.IO.Handle 0ec5f3e063751c91152d6f1b0286ca9a
import  -/  base-4.9.0.0:GHC.IO.Handle.FD 5311a39f33255d27517e14bdb344dca6
import  -/  base-4.9.0.0:GHC.IO.Handle.Text 31095aa055e219de705adc4ee34f86ea
import  -/  base-4.9.0.0:GHC.IO.Handle.Types 99ae375c1c1e5fd2b2a363d71767500f
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  base-4.9.0.0:System.IO c1068c4f4231e3198e330f99a58145b0
import  -/  base-4.9.0.0:Text.Read 575a1becf4a56881b7def2de5a4c3776
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Lazy 19646d445c770f98ae8d9258dfe37061
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Lazy.Internal dd6259a82bb04a667163961825e92546
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  iproute-1.7.1@iproute-1.7.1-EsJa15Wmnfj5pBTvNuT9V3:Data.IP beb936c818f476e9025b79a9979d88f5
import  -/  iproute-1.7.1@iproute-1.7.1-EsJa15Wmnfj5pBTvNuT9V3:Data.IP.Addr 59be9fd7ca76530500f602b282a2bca2
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Reader 859b39f57eb3bed457106c30aac21473
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Reader.Class 70af8bbe9a2a47df6e22d8f7d28d8a76
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State d851912d62cbc95e043a9cc13c3581de
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State.Class 6b9267d06a66633777f53733046c8d46
import  -/  network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX:Network.Socket 2f253729e20b2c01a052b224772cdc0e
import  -/  network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX:Network.Socket.ByteString.Lazy 0c008119a5691b8369bdcb39ebca71a2
import  -/  network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX:Network.Socket.ByteString.Lazy.Windows dcffaf81ce603714446568551bcb5452
import  -/  network-2.6.3.1@network-2.6.3.1-nK9qnsiJR03CWuPIGMmX:Network.Socket.Types ceee5c47a96573cf15aae5cc2281c723
import  -/  stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF:Control.Concurrent.STM 674516fe7a455ad46572e426b17538fa
import  -/  stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF:Control.Concurrent.STM.TChan 50e90dd10474a6f93eedf615dd557d02
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Reader 756452dbc99b10a10b52491debebc1d0
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy fd06dab0d634fc591e8c33380a9811a8
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dMonad :: GHC.Base.Monad m).
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fApplicativeMateMonad_$cp1Applicative
                     @ f
                     @ s
                     @ m
                     $dMonad)
                  (Network.MateLight.$fApplicativeMateMonad_$cpure
                     @ f
                     @ s
                     @ m
                     $dMonad)
                  (Network.MateLight.$fApplicativeMateMonad_$c<*>
                     @ f
                     @ s
                     @ m
                     $dMonad)
                  (Network.MateLight.$fApplicativeMateMonad_$c*> @ f @ s @ m $dMonad)
                  (Network.MateLight.$fApplicativeMateMonad_$c<*
                     @ f
                     @ s
                     @ m
                     $dMonad) -}
9ab94a334b6518b3193ebdaa25e690a6
  $fApplicativeMateMonad1 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
    -> s
    -> Control.Monad.Trans.Reader.ReaderT f m (a, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(1*U(1*C1(U),A),C(U),A,A,A),C(C1(U)),A,A,A)><L,1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             s (Control.Monad.Trans.Reader.ReaderT f m) a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              s (Control.Monad.Trans.Reader.ReaderT f m) b)
                   (eta2 :: s) ->
                 let {
                   lvl21 :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   f1 :: m (a, s) -> m (b -> a, s)
                   = GHC.Base.fmap
                       @ m
                       (GHC.Base.$p1Applicative @ m lvl21)
                       @ (a, s)
                       @ (b -> a, s)
                       (Control.Monad.Trans.State.Lazy.$fApplicativeStateT2 @ b @ a @ s)
                 } in
                 let {
                   g :: Control.Monad.Trans.Reader.ReaderT f m (a, s)
                   = eta
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N)
                       eta2
                 } in
                 (\ (r1 :: f) ->
                  GHC.Base.>>=
                    @ m
                    $dMonad
                    @ (b -> a, s)
                    @ (a, s)
                    (f1
                       (g `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N <f>_R <m>_R <(a, s)>_N)
                          r1))
                    (\ (a1 :: (b -> a, s)) ->
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (b, s)
                       @ (a, s)
                       ((eta1
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <b>_N)
                           (case a1 of wild { (,) f2 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N <f>_R <m>_R <(b, s)>_N)
                          r1)
                       (\ (a2 :: (b, s)) ->
                        GHC.Base.pure
                          @ m
                          lvl21
                          @ (a, s)
                          (case a1 of wild { (,) f2 s' ->
                           f2 (case a2 of wild1 { (,) x s'' -> x }) },
                           case a2 of wild { (,) x s'' -> s'' }))))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(a, s)>_N))) -}
39aa99eee0b30e7cce1c03a004f323c9
  $fApplicativeMateMonad2 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
    -> s
    -> Control.Monad.Trans.Reader.ReaderT f m (b, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(1*U(1*C1(U),A),C(U),A,A,A),C(C1(U)),A,A,A)><L,1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b
                   (eta :: Control.Monad.Trans.State.Lazy.StateT
                             s (Control.Monad.Trans.Reader.ReaderT f m) a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              s (Control.Monad.Trans.Reader.ReaderT f m) b)
                   (eta2 :: s) ->
                 let {
                   lvl21 :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   f1 :: m (a, s) -> m (b -> b, s)
                   = GHC.Base.fmap
                       @ m
                       (GHC.Base.$p1Applicative @ m lvl21)
                       @ (a, s)
                       @ (b -> b, s)
                       (Control.Monad.Trans.State.Lazy.$fApplicativeStateT4 @ b @ a @ s)
                 } in
                 let {
                   g :: Control.Monad.Trans.Reader.ReaderT f m (a, s)
                   = eta
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N)
                       eta2
                 } in
                 (\ (r1 :: f) ->
                  GHC.Base.>>=
                    @ m
                    $dMonad
                    @ (b -> b, s)
                    @ (b, s)
                    (f1
                       (g `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N <f>_R <m>_R <(a, s)>_N)
                          r1))
                    (\ (a1 :: (b -> b, s)) ->
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (b, s)
                       @ (b, s)
                       ((eta1
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <b>_N)
                           (case a1 of wild { (,) f2 s' -> s' }))
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N <f>_R <m>_R <(b, s)>_N)
                          r1)
                       (\ (a2 :: (b, s)) ->
                        GHC.Base.pure
                          @ m
                          lvl21
                          @ (b, s)
                          (case a1 of wild { (,) f2 s' ->
                           f2 (case a2 of wild1 { (,) x s'' -> x }) },
                           case a2 of wild { (,) x s'' -> s'' }))))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(b, s)>_N))) -}
38e3bf20b87b04c13b0eb32515d82b77
  $fApplicativeMateMonad3 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      s (Control.Monad.Trans.Reader.ReaderT f m) (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   @ b ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*>
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fFunctorReaderT
                      @ m
                      @ f
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad)))
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)
                   @ a
                   @ b) -}
7e40f4de55da90b6f19932b16a4ad2cf
  $fApplicativeMateMonad4 ::
    GHC.Base.Monad m =>
    forall a.
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a ->
                 Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fFunctorReaderT
                      @ m
                      @ f
                      (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad)))
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)
                   @ a) -}
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad_$c*> ::
    GHC.Base.Monad m =>
    forall a b.
    Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m b
    -> Network.MateLight.MateMonad f s m b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(1*U(1*C1(U),A),C(U),A,A,A),C(C1(U)),A,A,A)><L,1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fApplicativeMateMonad2
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <b>_N
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <b>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <b>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad_$c<* ::
    GHC.Base.Monad m =>
    forall a b.
    Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m b
    -> Network.MateLight.MateMonad f s m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(1*U(1*C1(U),A),C(U),A,A,A),C(C1(U)),A,A,A)><L,1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fApplicativeMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <b>_N
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <a>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad_$c<*> ::
    GHC.Base.Monad m =>
    forall a b.
    Network.MateLight.MateMonad f s m (a -> b)
    -> Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fApplicativeMateMonad3
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a -> b>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <b>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad_$cp1Applicative ::
    GHC.Base.Monad m =>
    GHC.Base.Functor (Network.MateLight.MateMonad f s m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(C(U),A),A,A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ f @ s @ (m :: * -> *) ($dMonad :: GHC.Base.Monad m) ->
                 Network.MateLight.$fFunctorMateMonad
                   @ f
                   @ s
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))) -}
6afcb609693f9c966fad38874fdb846a
  $fApplicativeMateMonad_$cpure ::
    GHC.Base.Monad m =>
    forall a. a -> Network.MateLight.MateMonad f s m a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fApplicativeMateMonad4
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <a>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <a>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fFunctorMateMonad ::
    GHC.Base.Functor m =>
    GHC.Base.Functor (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(U),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dFunctor :: GHC.Base.Functor m).
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fFunctorMateMonad_$cfmap @ f @ s @ m $dFunctor)
                  (Network.MateLight.$fFunctorMateMonad_$c<$
                     @ f
                     @ s
                     @ m
                     $dFunctor) -}
62d559f88960574a8f877cb337271a9b
  $fFunctorMateMonad1 ::
    GHC.Base.Functor m =>
    forall a b.
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
    -> s
    -> Control.Monad.Trans.Reader.ReaderT f m (a, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,U><L,1*C1(U)><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dFunctor :: GHC.Base.Functor m)
                   @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              s (Control.Monad.Trans.Reader.ReaderT f m) b)
                   (s1 :: s) ->
                 let {
                   f1 :: m (b, s) -> m (a, s)
                   = GHC.Base.fmap
                       @ m
                       $dFunctor
                       @ (b, s)
                       @ (a, s)
                       (\ (ds1 :: (b, s)) -> (eta, case ds1 of wild { (,) a1 s' -> s' }))
                 } in
                 let {
                   g :: Control.Monad.Trans.Reader.ReaderT f m (b, s)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <b>_N)
                       s1
                 } in
                 (\ (x :: f) ->
                  f1
                    (g `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N <f>_R <m>_R <(b, s)>_N)
                       x))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(a, s)>_N))) -}
ef8bf131d31f566de2e5fd890853f259
  $fFunctorMateMonad2 ::
    GHC.Base.Functor m =>
    forall a b.
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dFunctor :: GHC.Base.Functor m)
                   @ a
                   @ b ->
                 Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fFunctorReaderT @ m @ f $dFunctor)
                   @ a
                   @ b) -}
6afcb609693f9c966fad38874fdb846a
  $fFunctorMateMonad_$c<$ ::
    GHC.Base.Functor m =>
    forall a b.
    a
    -> Network.MateLight.MateMonad f s m b
    -> Network.MateLight.MateMonad f s m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,U><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fFunctorMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Functor m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <a>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <b>_N
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <a>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fFunctorMateMonad_$cfmap ::
    GHC.Base.Functor m =>
    forall a b.
    (a -> b)
    -> Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m b
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C(U)),A)>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fFunctorMateMonad2
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Functor m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <a -> b>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <b>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadIOMateMonad ::
    Control.Monad.IO.Class.MonadIO m =>
    Control.Monad.IO.Class.MonadIO (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(U,U),U,U,U,U),U,U,U,U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dMonadIO :: Control.Monad.IO.Class.MonadIO m).
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fMonadIOMateMonad_$cp1MonadIO
                     @ f
                     @ s
                     @ m
                     $dMonadIO)
                  (Network.MateLight.$fMonadIOMateMonad_$cliftIO
                     @ f
                     @ s
                     @ m
                     $dMonadIO) -}
e3f3214d1ce30c1c76924a53d3b97d1a
  $fMonadIOMateMonad1 ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a.
    GHC.Types.IO a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*C1(U))><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (eta :: GHC.Types.IO a) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   lvl21 :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   x :: m a = Control.Monad.IO.Class.liftIO @ m $dMonadIO @ a eta
                 } in
                 (\ (s1 :: s) (r1 :: f) ->
                  GHC.Base.>>=
                    @ m
                    $dMonad
                    @ a
                    @ (a, s)
                    x
                    (\ (a1 :: a) -> GHC.Base.pure @ m lvl21 @ (a, s) (a1, s1)))
                   `cast`
                 (Trans
                      (<s>_R
                       ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                     <*>_N <f>_R <m>_R <(a, s)>_N))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N)))) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadIOMateMonad_$cliftIO ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a. GHC.Types.IO a -> Network.MateLight.MateMonad f s m a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadIOMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <Control.Monad.IO.Class.MonadIO m>_R
                 ->_R forall (a :: <*>_N).
                      <GHC.Types.IO a>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <a>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadIOMateMonad_$cp1MonadIO ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Base.Monad (Network.MateLight.MateMonad f s m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 Network.MateLight.$fMonadMateMonad
                   @ f
                   @ s
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadMateMonad ::
    GHC.Base.Monad m =>
    GHC.Base.Monad (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dMonad :: GHC.Base.Monad m).
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fApplicativeMateMonad @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadMateMonad_$c>>= @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadMateMonad_$c>> @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadMateMonad_$creturn @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadMateMonad_$cfail @ f @ s @ m $dMonad) -}
d0fa2a0999b9985676230d06c7942817
  $fMonadMateMonad1 ::
    GHC.Base.Monad m =>
    forall a.
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ f @ s @ (m :: * -> *) ($dMonad :: GHC.Base.Monad m) @ a ->
                 Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)
                   @ a) -}
c6f5f6159c1fee2f0bc4b09d35d147a4
  $fMonadMateMonad2 ::
    GHC.Base.Monad m =>
    forall a. a -> s -> Control.Monad.Trans.Reader.ReaderT f m (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (eta :: a)
                   (eta1 :: s) ->
                 let {
                   m1 :: m (a, s)
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad @ m $dMonad)
                       @ (a, s)
                       (eta, eta1)
                 } in
                 (\ (eta2 :: f) -> m1)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(a, s)>_N))) -}
070af9b2d5b0e245a18ceb808c39f64a
  $fMonadMateMonad3 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ f @ s @ (m :: * -> *) ($dMonad :: GHC.Base.Monad m) @ a @ b ->
                 Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)
                   @ a
                   @ b) -}
5e869e11ea31813aa4896cc192e95829
  $fMonadMateMonad4 ::
    GHC.Base.Monad m =>
    forall a b.
    Control.Monad.Trans.State.Lazy.StateT
      s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s (Control.Monad.Trans.Reader.ReaderT f m) b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ f @ s @ (m :: * -> *) ($dMonad :: GHC.Base.Monad m) @ a @ b ->
                 Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>=
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)
                   @ a
                   @ b) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadMateMonad_$c>> ::
    GHC.Base.Monad m =>
    forall a b.
    Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m b
    -> Network.MateLight.MateMonad f s m b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadMateMonad3
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <b>_N
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <b>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadMateMonad_$c>>= ::
    GHC.Base.Monad m =>
    forall a b.
    Network.MateLight.MateMonad f s m a
    -> (a -> Network.MateLight.MateMonad f s m b)
    -> Network.MateLight.MateMonad f s m b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadMateMonad4
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R (<a>_R
                            ->_R Sym (Network.MateLight.N:MateMonad[0]
                                          <f>_R <s>_N <m>_R) <b>_N)
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <b>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadMateMonad_$cfail ::
    GHC.Base.Monad m =>
    forall a. GHC.Base.String -> Network.MateLight.MateMonad f s m a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <[GHC.Types.Char]>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <a>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadMateMonad_$creturn ::
    GHC.Base.Monad m =>
    forall a. a -> Network.MateLight.MateMonad f s m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadMateMonad2
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <a>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <a>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadReaderMateMonad ::
    GHC.Base.Monad m =>
    Control.Monad.Reader.Class.MonadReader
      f (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dMonad :: GHC.Base.Monad m).
                  @ f
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fMonadMateMonad @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadReaderMateMonad_$cask
                     @ f
                     @ s
                     @ m
                     $dMonad)
                  (Network.MateLight.$fMonadReaderMateMonad_$clocal
                     @ f
                     @ s
                     @ m
                     $dMonad)
                  (Network.MateLight.$fMonadReaderMateMonad_$creader
                     @ f
                     @ s
                     @ m
                     $dMonad) -}
a6e2e06c353c6002683a69c0f9cc8150
  $fMonadReaderMateMonad1 ::
    GHC.Base.Monad m => forall a. (f -> a) -> s -> f -> m (a, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(U(A,C(U),A,A,A),1*C1(C1(U)),A,1*C1(U),A)><L,1*C1(U)><L,U><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (eta :: f -> a)
                   (s1 :: s)
                   (r1 :: f) ->
                 let {
                   lvl21 :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ a
                   @ (a, s)
                   (GHC.Base.return @ m $dMonad @ a (eta r1))
                   (\ (a1 :: a) -> GHC.Base.pure @ m lvl21 @ (a, s) (a1, s1))) -}
6c7408a5c6c7039b4af4e0bebb1b039d
  $fMonadReaderMateMonad2 ::
    GHC.Base.Monad m =>
    forall a.
    (f -> f)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
    -> s
    -> Control.Monad.Trans.Reader.ReaderT f m (a, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,C(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (eta :: f -> f)
                   (eta1 :: Control.Monad.Trans.State.Lazy.StateT
                              s (Control.Monad.Trans.Reader.ReaderT f m) a)
                   (eta2 :: s) ->
                 let {
                   eta3 :: Control.Monad.Trans.Reader.ReaderT f m (a, s)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N)
                       eta2
                 } in
                 (\ (eta4 :: f) ->
                  eta3
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <*>_N <f>_R <m>_R <(a, s)>_N)
                    (eta eta4))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(a, s)>_N))) -}
86d61c88cad4be630b054b51298e8716
  $fMonadReaderMateMonad3 :: GHC.Base.Monad m => s -> f -> m (f, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(U(A,C(U),A,A,A),1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
     Unfolding: (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: s)
                   (eta1 :: f) ->
                 let {
                   lvl21 :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ f
                   @ (f, s)
                   (GHC.Base.return @ m $dMonad @ f eta1)
                   (\ (a1 :: f) -> GHC.Base.pure @ m lvl21 @ (f, s) (a1, eta))) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadReaderMateMonad_$cask ::
    GHC.Base.Monad m => Network.MateLight.MateMonad f s m f
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(U(A,C(U),A,A,A),1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadReaderMateMonad3
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R Trans
                          (<s>_R
                           ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N <f>_R <m>_R <(f, s)>_N))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <f>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <f>_N))) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadReaderMateMonad_$clocal ::
    GHC.Base.Monad m =>
    forall a.
    (f -> f)
    -> Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,C(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadReaderMateMonad2
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <f -> f>_R
                      ->_R Sym (Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R) <a>_N
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <a>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadReaderMateMonad_$creader ::
    GHC.Base.Monad m =>
    forall a. (f -> a) -> Network.MateLight.MateMonad f s m a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(U(A,C(U),A,A,A),1*C1(C1(U)),A,1*C1(U),A)><L,1*C1(U)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadReaderMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <f -> a>_R
                      ->_R Trans
                               (<s>_R
                                ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                              <*>_N <f>_R <m>_R <(a, s)>_N))
                               (Trans
                                    (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                              <s>_N
                                              <Control.Monad.Trans.Reader.ReaderT f m>_R
                                              <a>_N))
                                    (Sym (Network.MateLight.N:MateMonad[0]
                                              <f>_R <s>_N <m>_R) <a>_N))) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadStateMateMonad ::
    GHC.Base.Monad m =>
    Control.Monad.State.Class.MonadState
      s (Network.MateLight.MateMonad f s m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ f
                      @ s
                      @ (m :: * -> *)
                      ($dMonad :: GHC.Base.Monad m).
                  @ s
                  @ (Network.MateLight.MateMonad f s m)
                  (Network.MateLight.$fMonadMateMonad @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadStateMateMonad_$cget @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadStateMateMonad_$cput @ f @ s @ m $dMonad)
                  (Network.MateLight.$fMonadStateMateMonad_$cstate
                     @ f
                     @ s
                     @ m
                     $dMonad) -}
bf61448f2f5c1b2ae7d47e148d0e8001
  $fMonadStateMateMonad1 ::
    GHC.Base.Monad m =>
    forall a.
    (s -> (a, s)) -> s -> Control.Monad.Trans.Reader.ReaderT f m (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (eta :: s -> (a, s))
                   (eta1 :: s) ->
                 let {
                   m1 :: m (a, s)
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad @ m $dMonad)
                       @ (a, s)
                       (eta eta1)
                 } in
                 (\ (eta2 :: f) -> m1)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(a, s)>_N))) -}
0343823ee03612fe8c59d1e4a05c7b51
  $fMonadStateMateMonad2 ::
    GHC.Base.Monad m =>
    s
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ f @ s @ (m :: * -> *) ($dMonad :: GHC.Base.Monad m) ->
                 Control.Monad.Trans.State.Lazy.put
                   @ (Control.Monad.Trans.Reader.ReaderT f m)
                   @ s
                   (Control.Monad.Trans.Reader.$fMonadReaderT @ m @ f $dMonad)) -}
2b4e21db7c14db1cbf7c74f7e3312a46
  $fMonadStateMateMonad3 ::
    GHC.Base.Monad m =>
    s -> Control.Monad.Trans.Reader.ReaderT f m (s, s)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: s) ->
                 let {
                   m1 :: m (s, s)
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad @ m $dMonad)
                       @ (s, s)
                       (eta, eta)
                 } in
                 (\ (eta1 :: f) -> m1)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N <f>_R <m>_R <(s, s)>_N))) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadStateMateMonad_$cget ::
    GHC.Base.Monad m => Network.MateLight.MateMonad f s m s
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadStateMateMonad3
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <s>_N))
                          (Sym (Network.MateLight.N:MateMonad[0]
                                    <f>_R <s>_N <m>_R) <s>_N)) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadStateMateMonad_$cput ::
    GHC.Base.Monad m => s -> Network.MateLight.MateMonad f s m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(U),A),C(U),C(C1(U)),A,A),C(C1(U)),A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadStateMateMonad2
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R <s>_R
                 ->_R Sym (Network.MateLight.N:MateMonad[0]
                               <f>_R <s>_N <m>_R) <()>_N) -}
6afcb609693f9c966fad38874fdb846a
  $fMonadStateMateMonad_$cstate ::
    GHC.Base.Monad m =>
    forall a. (s -> (a, s)) -> Network.MateLight.MateMonad f s m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.$fMonadStateMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Monad m>_R
                 ->_R forall (a :: <*>_N).
                      <s -> (a, s)>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <s>_N <Control.Monad.Trans.Reader.ReaderT f m>_R <a>_N))
                               (Sym (Network.MateLight.N:MateMonad[0]
                                         <f>_R <s>_N <m>_R) <a>_N)) -}
8638020a3d8046727f9d5490cccce8d9
  $fShowEventT :: GHC.Show.Show Network.MateLight.EventT
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Network.MateLight.EventT
                  Network.MateLight.$fShowEventT_$cshowsPrec
                  Network.MateLight.$fShowEventT_$cshow
                  Network.MateLight.$fShowEventT_$cshowList -}
8638020a3d8046727f9d5490cccce8d9
  $fShowEventT1 ::
    Network.MateLight.EventT -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (x :: Network.MateLight.EventT)
                   (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Network.MateLight.$fShowEventT_$cshow x)
                   s) -}
edd81e0269743b6a670b6897dd8f1605
  $fShowEventT2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows8
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8638020a3d8046727f9d5490cccce8d9
  $fShowEventT_$cshow :: Network.MateLight.EventT -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds1 :: Network.MateLight.EventT) ->
                 case ds1 of wild { Network.MateLight.EventT a $dTypeable1 $dShow mod a1 ->
                 GHC.CString.unpackAppendCString#
                   "Event "#
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows8
                         (GHC.Show.showLitString mod Network.MateLight.$fShowEventT2))
                      (GHC.CString.unpackAppendCString#
                         " "#
                         (GHC.Show.show @ a $dShow a1))) }) -}
8638020a3d8046727f9d5490cccce8d9
  $fShowEventT_$cshowList ::
    [Network.MateLight.EventT] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Network.MateLight.EventT])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Network.MateLight.EventT
                   Network.MateLight.$fShowEventT1
                   ls
                   s) -}
8638020a3d8046727f9d5490cccce8d9
  $fShowEventT_$cshowsPrec ::
    GHC.Types.Int -> Network.MateLight.EventT -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds1 :: GHC.Types.Int)
                   (x :: Network.MateLight.EventT)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Network.MateLight.$fShowEventT_$cshow x))
                   s) -}
d3290f3278de35a5b5785a2290dee3de
  $stypeRep#2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Network.MateLight.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tcChar
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
b26a086ea92f1b1960a236851ce029a4
  $stypeRep#3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   16781394633280494409##
                   2520638044472077920##) -}
83329fb85f4ce4a7ead9089b35e77fd6
  $stypeRep#6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Network.MateLight.$stypeRep#7
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tc[]
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
581d2aefc8e4c9144e97c4f5188b9f1c
  $stypeRep#7 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17730107610217102821##
                   9866972337190828755##) -}
0e022775ed8164d33f0a6d3284a73d53
  $tc'C:Frame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9455271235523723104##
                   17031589697627164136##
                   Network.MateLight.$trModule
                   Network.MateLight.$tc'C:Frame1) -}
905a08ee125ad8358f367427f4f55994
  $tc'C:Frame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Frame"#) -}
54732847f4dae7ffd5e11bc553c924a5
  $tc'Config :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10765029633997050254##
                   17733643711667222321##
                   Network.MateLight.$trModule
                   Network.MateLight.$tc'Config1) -}
4d7c5b524a69c6a6b9179765ad79e394
  $tc'Config1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Config"#) -}
6b5f32577024edbb54b6adab65a20717
  $tc'EventT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16245235308409471221##
                   9109578313736619636##
                   Network.MateLight.$trModule
                   Network.MateLight.$tc'EventT1) -}
d774a6f9351b8441df4ed7a3b1888257
  $tc'EventT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EventT"#) -}
5024e2b6a43b026f0645e86796886387
  $tc'MateMonad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7037622514989162757##
                   15866574076372641199##
                   Network.MateLight.$trModule
                   Network.MateLight.$tc'MateMonad1) -}
38f345eadb36921822cfeb2e2d803a72
  $tc'MateMonad1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MateMonad"#) -}
cd5e5f8a24c6c350a7a918f8c7ea48a3
  $tcConfig :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16034955317817203263##
                   12155472328361362327##
                   Network.MateLight.$trModule
                   Network.MateLight.$tcConfig1) -}
3987a755c9b7ae8d0e994da864fbce3c
  $tcConfig1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Config"#) -}
d52db018c25db142091bb537b90986b2
  $tcEventT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2899875871843566401##
                   6038492000738045606##
                   Network.MateLight.$trModule
                   Network.MateLight.$tcEventT1) -}
6d3b6f10da9dced4e2bb1e28abf7dff3
  $tcEventT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "EventT"#) -}
0faff993f23e8d71259df0b68d73e3a1
  $tcFrame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14495730384560788985##
                   10662579003817979501##
                   Network.MateLight.$trModule
                   Network.MateLight.$tcFrame1) -}
50910bbef0cd34292caab07e8e5e2487
  $tcFrame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Frame"#) -}
9d587763e7e618147042e80b65af135f
  $tcMateMonad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6215295594270465697##
                   2431754849499505266##
                   Network.MateLight.$trModule
                   Network.MateLight.$tcMateMonad1) -}
160b258c089e91114bcd6d8967eec2c6
  $tcMateMonad1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "MateMonad"#) -}
d54b8343bc3c49b751cca6186adde42c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Network.MateLight.$trModule2
                   Network.MateLight.$trModule1) -}
9c41ad8a153cff26c8e0228fa1a15c91
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Network.MateLight"#) -}
4f57a149a603a88f1003f240d5edc7fc
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HSMateLight-0.1.0.0-Df1CB9554xjHvhQtZIZ9Dm"#) -}
d2c3b7afe99892caa860a9e89a707935
  data Config
    = Config {cAddr :: Data.IP.Addr.IP,
              cPort :: Network.Socket.Types.PortNumber,
              cDimension :: (GHC.Types.Int, GHC.Types.Int),
              cStepTime :: GHC.Base.Maybe GHC.Types.Int,
              cSynchronized :: GHC.Types.Bool,
              cEventProviders :: [Network.MateLight.EventProviderT]}
bf6a167546995fb13c09ce4cd4088a85
  type EventProviderT =
    Control.Concurrent.STM.TChan.TChan Network.MateLight.EventT
    -> GHC.Types.IO ()
8638020a3d8046727f9d5490cccce8d9
  data EventT where
    EventT :: (Data.Typeable.Internal.Typeable a, GHC.Show.Show a) =>
              GHC.Base.String -> a -> EventT
6621d4895ac382459e9f45a9432ee27c
  class Frame f where
    theData :: f -> Data.ByteString.Lazy.Internal.ByteString
    dimension :: f -> (GHC.Types.Int, GHC.Types.Int)
    {-# MINIMAL theData, dimension #-}
6afcb609693f9c966fad38874fdb846a
  type role MateMonad representational nominal representational nominal
  newtype MateMonad f s (m :: * -> *) a
    = MateMonad {unMateMonad :: Control.Monad.Trans.State.Lazy.StateT
                                  s (Control.Monad.Trans.Reader.ReaderT f m) a}
2fdc5c2314ee7f5c488bd0fd6261dba4
  cAddr :: Network.MateLight.Config -> Data.IP.Addr.IP
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLL),1*U(1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
448117794d96fcd0aae319037e23a687
  cDimension ::
    Network.MateLight.Config -> (GHC.Types.Int, GHC.Types.Int)
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLL),1*U(A,A,1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
f5ade5bd3a05c0601236f9b5d323db70
  cEventProviders ::
    Network.MateLight.Config -> [Network.MateLight.EventProviderT]
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLS),1*U(A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
f12cb8bda675e00f9d6778378332debe
  cPort ::
    Network.MateLight.Config -> Network.Socket.Types.PortNumber
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLL),1*U(A,1*U(U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
3f23665abb3cf09a256b200b2ebdbfc0
  cStepTime ::
    Network.MateLight.Config -> GHC.Base.Maybe GHC.Types.Int
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
924882553bacd0b6a563912089a6b76e
  cSynchronized :: Network.MateLight.Config -> GHC.Types.Bool
  RecSel Left Network.MateLight.Config
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSL),1*U(A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Network.MateLight.Config) ->
                 case ds1 of wild { Network.MateLight.Config ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
1a72b5e8b2ee877deacd22d8d328e7ad
  parseAddress :: GHC.Base.String -> GHC.Base.Maybe Data.IP.Addr.IP
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (str :: GHC.Base.String) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Base.Maybe Data.IP.Addr.IP
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case Data.IP.Addr.skipSpaces of wild { Text.Appar.Parser.P ds1 ->
                     case ds1 str of wild1 { (,) ds2 bs' ->
                     case ds2 of wild2 {
                       GHC.Base.Nothing -> GHC.Base.Nothing @ Data.IP.Addr.IP
                       GHC.Base.Just a1
                       -> case Data.IP.Addr.parseIP_k1 of wild3 { Text.Appar.Parser.P ds3 ->
                          case ds3 bs' of wild4 { (,) ds4 ds5 ->
                          case ds4 of wild5 {
                            GHC.Base.Nothing -> GHC.Base.Nothing @ Data.IP.Addr.IP
                            GHC.Base.Just a4
                            -> case ds5 of wild7 {
                                 [] -> GHC.Base.Just @ Data.IP.Addr.IP (Data.IP.Addr.IPv4 a4)
                                 : ipv ipv1 -> GHC.Base.Nothing @ Data.IP.Addr.IP } } } } } } }
                 } in
                 case Text.ParserCombinators.ReadP.run
                        @ (GHC.Base.Maybe Data.IP.Addr.IPv6)
                        Network.MateLight.parseAddress1
                        str of wild {
                   [] -> $j GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) a ds3 ->
                      case ds3 of wild2 {
                        []
                        -> case ds2 of wild3 {
                             []
                             -> case a of wild4 {
                                  GHC.Base.Nothing -> GHC.Base.Nothing @ Data.IP.Addr.IP
                                  GHC.Base.Just x
                                  -> GHC.Base.Just @ Data.IP.Addr.IP (Data.IP.Addr.IPv6 x) }
                             : ipv ipv1 -> $j GHC.Prim.void# }
                        : ipv ipv1 -> $j GHC.Prim.void# } } }) -}
494f1dae5c1e4f528ac62ec8dbe64231
  parseAddress1 ::
    Text.ParserCombinators.ReadP.P (GHC.Base.Maybe Data.IP.Addr.IPv6)
  {- Unfolding: ((GHC.Read.$fReadMaybe2
                    @ Data.IP.Addr.IPv6
                    Data.IP.Addr.$fReadIPv6
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <GHC.Base.Maybe Data.IP.Addr.IPv6>_R)
                   @ (GHC.Base.Maybe Data.IP.Addr.IPv6)
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ (GHC.Base.Maybe Data.IP.Addr.IPv6))) -}
8624911527d7fdb8b6017120da2f723b
  runMateM ::
    Network.MateLight.Frame f =>
    Network.MateLight.Config
    -> ([Network.MateLight.EventT]
        -> Network.MateLight.MateMonad f s GHC.Types.IO f)
    -> s
    -> GHC.Types.IO ()
  {- Arity: 5,
     Strictness: <L,U(C(U),A)><L,1*U(1*U,U,1*U(1*U(U),1*U(U)),1*U,U,1*U)><L,C(C1(C1(C1(U(U,1*U(U,U))))))><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.runMateM1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N).
                 <Network.MateLight.Frame f>_R
                 ->_R <Network.MateLight.Config>_R
                 ->_R <[Network.MateLight.EventT]
                       -> Network.MateLight.MateMonad f s GHC.Types.IO f>_R
                 ->_R <s>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
504262ae08fec46ca4ec8d5c396c0c17
  runMateM1 ::
    Network.MateLight.Frame f =>
    Network.MateLight.Config
    -> ([Network.MateLight.EventT]
        -> Network.MateLight.MateMonad f s GHC.Types.IO f)
    -> s
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 5,
     Strictness: <L,U(C(U),A)><L,1*U(1*U,U,1*U(1*U(U),1*U(U)),1*U,U,1*U)><L,C(C1(C1(C1(U(U,1*U(U,U))))))><L,U><S,U> -}
7f4f0d392a2503b11b5f3054d8c5c684
  unMateMonad ::
    Network.MateLight.MateMonad f s m a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Control.Monad.Trans.Reader.ReaderT f m) a
  RecSel Left Network.MateLight.MateMonad
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Network.MateLight.unMateMonad1
                  `cast`
                (forall (f :: <*>_N) (s :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Network.MateLight.MateMonad f s m a>_R
                 ->_R Network.MateLight.N:MateMonad[0] <f>_R <s>_N <m>_R <a>_N) -}
a33f600bf40c8689d9d3e6b210b234b6
  unMateMonad1 ::
    Network.MateLight.MateMonad f s m a
    -> Network.MateLight.MateMonad f s m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ f
                   @ s
                   @ (m :: * -> *)
                   @ a
                   (ds1 :: Network.MateLight.MateMonad f s m a) ->
                 ds1) -}
instance GHC.Base.Applicative [Network.MateLight.MateMonad]
  = Network.MateLight.$fApplicativeMateMonad
instance GHC.Base.Functor [Network.MateLight.MateMonad]
  = Network.MateLight.$fFunctorMateMonad
instance Control.Monad.IO.Class.MonadIO [Network.MateLight.MateMonad]
  = Network.MateLight.$fMonadIOMateMonad
instance GHC.Base.Monad [Network.MateLight.MateMonad]
  = Network.MateLight.$fMonadMateMonad
instance Control.Monad.Reader.Class.MonadReader [.,
                                                 Network.MateLight.MateMonad]
  = Network.MateLight.$fMonadReaderMateMonad
instance Control.Monad.State.Class.MonadState [.,
                                               Network.MateLight.MateMonad]
  = Network.MateLight.$fMonadStateMateMonad
instance GHC.Show.Show [Network.MateLight.EventT]
  = Network.MateLight.$fShowEventT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

